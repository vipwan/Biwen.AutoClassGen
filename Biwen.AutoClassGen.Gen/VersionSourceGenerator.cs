// <copyright file="SourceGenCodeFixProvider.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace Biwen.AutoClassGen;

/// <summary>
/// 生成版本信息
/// </summary>
[Generator]
public class VersionSourceGenerator : IIncrementalGenerator
{
    private const string DefaultVersion = "1.0.0";

    private readonly record struct VersionInfo(string? Namespace, string? File);

    #region consts

    private const string ODir = "build_property.projectdir"; // 项目目录
    private const string ONamespace = "build_property.rootnamespace"; // 命名空间
    private const string ProjExt = ".csproj"; // 项目文件扩展名
    private const string ConfigTag = "Biwen-AutoClassGen"; // 配置标签

    #endregion

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 获取项目信息
        var inc = context.AnalyzerConfigOptionsProvider.Select((pvd, _) =>
        {
            // 取得项目目录
            var flag = pvd.GlobalOptions.TryGetValue(ODir, out var root);
            if (!flag)
                return new VersionInfo(null, null);

            // 取得命名空间
            pvd.GlobalOptions.TryGetValue(ONamespace, out var @namespace);

            // 查找csproj文件
            var files = Directory.GetFiles(root, $"*{ProjExt}", SearchOption.TopDirectoryOnly);

            return new VersionInfo(@namespace, files.Length == 0 ? null : files[0]);
        });

        // 生成
        context.RegisterSourceOutput(inc, (ctx, info) =>
        {
#pragma warning disable CA1031 // 不捕获常规异常类型
            try
            {
                // 创建临时诊断文件，用于排查问题
                // string debugPath = Path.Combine(Path.GetTempPath(), "version_generator_debug.log");
                // File.AppendAllText(debugPath, $"开始处理项目: {info.File ?? "无文件"}\n");

                if (info.Namespace == null || info.File == null)
                    return;

                // 默认版本号
                string version = DefaultVersion;
                string fileVersion = DefaultVersion;
                string assemblyVersion = DefaultVersion;

                // 读取项目文件内容
                string projectContent = File.ReadAllText(info.File);

                // 检查是否禁用版本生成
                if (CheckConfigDisabled(projectContent))
                    return;

                // 创建属性字典和已处理文件集合
                Dictionary<string, string> properties = [];
                HashSet<string> processedFiles = new(StringComparer.OrdinalIgnoreCase)
                {
                    // 递归处理项目文件及其所有嵌套引用
                    info.File,
                };
                ProcessProjectFile(info.File, properties, processedFiles);

                // 提取版本信息
                version = GetPropertyValue(properties, "Version", DefaultVersion);
                fileVersion = GetPropertyValue(properties, "FileVersion", DefaultVersion);
                assemblyVersion = GetPropertyValue(properties, "AssemblyVersion", DefaultVersion);

                // 处理变量引用 $(VariableName)
                version = ResolveVariableReferences(version, properties);
                fileVersion = ResolveVariableReferences(fileVersion, properties);
                assemblyVersion = ResolveVariableReferences(assemblyVersion, properties);

                // 生成代码
                string source = $@"// <auto-generated/>
namespace {info.Namespace}.Generated;

/// <summary>
/// The version class
/// </summary>
[global::System.CodeDom.Compiler.GeneratedCode(""{ThisAssembly.Product}"", ""{ThisAssembly.FileVersion}"")]
public static class Version
{{
    /// <summary>
    /// The current version
    /// </summary>
    public static System.Version Current => System.Version.Parse(""{version}"");

    /// <summary>
    /// The file version
    /// </summary>
    public static System.Version FileVersion => System.Version.Parse(""{fileVersion}"");

    /// <summary>
    /// The assembly version
    /// </summary>
    public static System.Version AssemblyVersion => System.Version.Parse(""{assemblyVersion}"");
}}
";
                //格式化
                var sourceText = source.FormatContent();

                // 输出代码
                ctx.AddSource("version.g.cs", SourceText.From(sourceText, Encoding.UTF8));

                // File.AppendAllText(debugPath, $"成功生成代码，版本: {version}\n");
            }
            catch
            {
                // 记录异常信息，便于排查
                // string debugPath = Path.Combine(Path.GetTempPath(), "version_generator_error.log");
                // File.AppendAllText(debugPath, $"错误: {ex.Message}\n{ex.StackTrace}\n");
            }
#pragma warning restore CA1031 // 不捕获常规异常类型
        });
    }

    /// <summary>
    /// 递归处理项目文件及其导入
    /// </summary>
    /// <param name="filePath">项目文件路径</param>
    /// <param name="properties">收集的属性字典</param>
    /// <param name="processedFiles">已处理的文件集合，用于防止循环引用</param>
    private static void ProcessProjectFile(string filePath, Dictionary<string, string> properties, HashSet<string> processedFiles)
    {
#pragma warning disable CA1031 // 不捕获常规异常类型
        try
        {
            // 解析项目文件
            var projectXml = XDocument.Load(filePath);
            XNamespace ns = projectXml.Root?.GetDefaultNamespace() ?? string.Empty;

            // 收集当前文件中定义的属性
            foreach (var propertyGroup in projectXml.Root?.Elements(ns + "PropertyGroup") ?? [])
            {
                foreach (var prop in propertyGroup.Elements())
                {
                    // 以最先定义的属性为准，后续导入的不覆盖已存在的属性
                    // 这与 MSBuild 的加载顺序相反，可根据需要调整优先级
                    if (!properties.ContainsKey(prop.Name.LocalName))
                    {
                        properties[prop.Name.LocalName] = prop.Value;
                    }
                }
            }

            // 处理所有导入项
            foreach (var importElement in projectXml.Root?.Elements(ns + "Import") ?? [])
            {
                var importPath = importElement.Attribute("Project")?.Value;
                if (string.IsNullOrEmpty(importPath))
                    continue;

                // 计算完整路径
                string fullImportPath;
                if (Path.IsPathRooted(importPath))
                {
                    fullImportPath = importPath!;
                }
                else
                {
                    var baseDir = Path.GetDirectoryName(filePath) ?? string.Empty;
                    fullImportPath = Path.GetFullPath(Path.Combine(baseDir, importPath));
                }

                // 检查文件是否存在且未处理过（防止循环引用）
                if (File.Exists(fullImportPath) && !processedFiles.Contains(fullImportPath))
                {
                    // 标记为已处理
                    processedFiles.Add(fullImportPath);

                    // 递归处理导入文件
                    ProcessProjectFile(fullImportPath, properties, processedFiles);
                }
            }
        }
        catch
        {
            // 忽略处理项目文件时的异常
        }
#pragma warning restore CA1031 // 不捕获常规异常类型
    }

    /// <summary>
    /// 检查是否禁用了版本生成
    /// </summary>
    private static bool CheckConfigDisabled(string projectContent)
    {
        var match = Regex.Match(projectContent, $@"<{ConfigTag}>(.*?)</{ConfigTag}>", RegexOptions.Singleline);
        if (match.Success)
        {
            var config = match.Groups[1].Value;
            return config.ToLower(System.Globalization.CultureInfo.CurrentCulture).Contains("gv=false");
        }
        return false;
    }

    /// <summary>
    /// 从属性字典中获取属性值
    /// </summary>
    private static string GetPropertyValue(Dictionary<string, string> properties, string propertyName, string defaultValue)
    {
        if (properties.TryGetValue(propertyName, out var value) && !string.IsNullOrEmpty(value))
        {
            return value;
        }
        return defaultValue;
    }

    /// <summary>
    /// 解析属性中的变量引用，例如 $(VariableName)
    /// </summary>
    private static string ResolveVariableReferences(string value, Dictionary<string, string> properties)
    {
        if (string.IsNullOrEmpty(value))
            return value;

        // 查找 $(VarName) 形式的变量引用
        var variableRegex = new Regex(@"\$\(([^)]+)\)");
        var match = variableRegex.Match(value);
        int maxIterations = 10; // 防止无限循环
        int currentIteration = 0;

        while (match.Success && currentIteration < maxIterations)
        {
            currentIteration++;
            var varName = match.Groups[1].Value;
            if (properties.TryGetValue(varName, out var varValue))
            {
                // 替换变量引用
                value = value.Replace($"$({varName})", varValue);

                // 继续查找更多变量引用
                match = variableRegex.Match(value);
            }
            else
            {
                // 变量未找到，跳过此变量
                value = value.Replace($"$({varName})", string.Empty);
                match = match.NextMatch();
            }
        }

        return value;
    }
}
