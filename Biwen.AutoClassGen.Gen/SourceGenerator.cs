using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Biwen.AutoClassGen
{

    [Generator(LanguageNames.CSharp)]
#pragma warning disable RS1036 // 指定分析器禁止的 API 强制设置
    public class SourceGenerator : IIncrementalGenerator
#pragma warning restore RS1036 // 指定分析器禁止的 API 强制设置
    {

        const string AttributeMetadataName = "Biwen.AutoClassGen.Attributes.AutoGenAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
              AttributeMetadataName,
              (context, attributeSyntax) => true,
              (syntaxContext, _) => syntaxContext.TargetNode).Collect();


            IncrementalValueProvider<(Compilation, ImmutableArray<SyntaxNode>)> compilationAndTypes =
                context.CompilationProvider.Combine(nodes);

            context.RegisterSourceOutput(compilationAndTypes, static (spc, source) => HandleAnnotatedNodes(source.Item1, source.Item2, spc));

        }

        private static void HandleAnnotatedNodes(Compilation compilation, ImmutableArray<SyntaxNode> nodes, SourceProductionContext context)
        {

            var sb = new StringBuilder();
            sb.AppendLine("// Path: Biwen.AutoClassGen.Gen/SourceGenerator.cs");
            sb.AppendLine("// This file is generated by Biwen.AutoClassGen.SourceGenerator");
            sb.AppendLine("// Do not edit this file manually.");
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.ComponentModel;");
            sb.AppendLine("using System.ComponentModel.DataAnnotations;");
            sb.AppendLine("using System.Text;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("#pragma warning disable");

            sb.AppendLine("$namespace");

            sb.AppendLine();
            sb.AppendLine("namespace $ni");
            sb.AppendLine("{");
            sb.AppendLine("\t$classes");
            sb.AppendLine("}");
            sb.AppendLine("#pragma warning restore");

            string classTemp = $"public partial class $className : $interfaceName {{ $body }}";

            foreach (InterfaceDeclarationSyntax node in nodes.AsEnumerable().Cast<InterfaceDeclarationSyntax>())
            {
                if (node.BaseList == null)
                {
                    continue;
                }
                if (!node.BaseList.Types.Any())
                {
                    continue;
                }

                IList<string> namespaces = new List<string>();

                var className = (node.AttributeLists.AsEnumerable().First(
                    x => x.Attributes.Any(x => x.Name.ToFullString() == "AutoGen"))
                    as AttributeListSyntax).Attributes[0].ArgumentList!.Arguments[0].ToString();

                var rootNamespace = (node.AttributeLists.AsEnumerable().First(
                    x => x.Attributes.Any(x => x.Name.ToFullString() == "AutoGen"))
                    as AttributeListSyntax).Attributes[0].ArgumentList!.Arguments[1].ToString();

                StringBuilder bodyBuilder = new();

                var body = string.Empty;

                foreach (var baseType in node.BaseList.Types)
                {
                    var interfaceName = baseType.Type.ToString();

                    var symbols = compilation.GetSymbolsWithName(interfaceName);
                    foreach (ITypeSymbol symbol in symbols.Cast<ITypeSymbol>())
                    {
                        var fullNameSpace = symbol.ContainingNamespace.ToDisplayString();
                        //命名空间
                        if (!namespaces.Contains(fullNameSpace))
                        {
                            namespaces.Add(fullNameSpace);
                        }
                        symbol.GetMembers().OfType<IPropertySymbol>().ToList().ForEach(prop =>
                        {
                            //attributes:
                            var attributes = prop.GetAttributes();
                            string rawAttributes = string.Empty;
                            attributes.ToList().ForEach(attr =>
                            {
                                rawAttributes += $"[{attr}]\r\n";
                            });
                            //prop:
                            var raw = $"public {prop.Type.ToDisplayString()} {prop.Name} {{get;set;}}";
                            //body:
                            body += $"{rawAttributes}{raw}\r\n";
                        });
                    }
                }

                var rawClass = classTemp.Replace("$className", className.Replace("\"", ""));
                rawClass = rawClass.Replace("$interfaceName", node.Identifier.ToString());
                rawClass = rawClass.Replace("$body", body);
                //append:
                bodyBuilder.AppendLine(rawClass);

                string rawNamespace = string.Empty;
                namespaces.ToList().ForEach(ns =>
                {
                    rawNamespace += $"using {ns};\r\n";
                });

                var source = sb.ToString();
                source = source.Replace("$namespace", rawNamespace);
                source = source.Replace("$classes", bodyBuilder.ToString());
                source = source.Replace("$ni", rootNamespace.Replace("\"", ""));
                //format:
                source = FormatContent(source);
                context.AddSource($"Biwen.AutoClassGen.{node.Identifier.Text}.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        /// <summary>
        /// 格式化代码
        /// </summary>
        /// <param name="csCode"></param>
        /// <returns></returns>
        private static string FormatContent(string csCode)
        {
            var tree = CSharpSyntaxTree.ParseText(csCode);
            var root = tree.GetRoot().NormalizeWhitespace();
            var ret = root.ToFullString();
            return ret;
        }
    }
}